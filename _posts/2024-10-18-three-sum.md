---
title: Three Sum
date: 2024-10-18 17:00:00 +0530
categories: [Problem Solving, Questions]
tags: [dsa, sorting, two-pointers, array, hashset]
---

## Problem Statement

Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that:
- `i != j`, `i != k`, and `j != k`
- `nums[i] + nums[j] + nums[k] == 0`

The solution set must not contain duplicate triplets.

**Solve Here:** <a href="https://leetcode.com/problems/3sum/" target="_blank">3Sum</a>

### Examples:

| Input | Output |
|-------|--------|
| `nums = [-1,0,1,2,-1,-4]` | `[[-1,-1,2],[-1,0,1]]` |
| `nums = [0,1,1]` | `[]` |
| `nums = [0,0,0]` | `[[0,0,0]]` |

### Edge Cases:
1. **All positive or all negative numbers**: If all numbers are positive or negative, there can't be a triplet that sums to zero.
2. **Multiple identical numbers**: If there are multiple instances of the same number, care must be taken to avoid duplicate triplets in the output.

## Solution Approaches:

### 1. Using HashSet

* **Description:** Fix one number, and then use a hash set to find the other two numbers that sum to zero.
* **Time Complexity:** O(n²) – one loop to fix a number and another loop to find the two-sum using a hash set
* **Space Complexity:** O(n) – additional space for the hash set

```kotlin
fun threeSum(nums: IntArray): List<List<Int>> {
    val result = mutableListOf<List<Int>>()
    val seenTriplets = HashSet<List<Int>>()
    
    nums.sort()
    for (i in nums.indices) {
        val seen = mutableSetOf<Int>()
        for (j in i + 1 until nums.size) {
            val complement = -nums[i] - nums[j]
            if (seen.contains(complement)) {
                val triplet = listOf(nums[i], complement, nums[j]).sorted()
                if (!seenTriplets.contains(triplet)) {
                    result.add(triplet)
                    seenTriplets.add(triplet)
                }
            }
            seen.add(nums[j])
        }
    }
    return result
}
```

### 2. Two Pointers

* **Description:** First, sort the array, then iterate through each number and use two pointers (left and right) to find two other numbers that sum to zero. After finding a valid triplet, move both pointers inward while avoiding duplicates.
* **Time Complexity:** O(n²) – one loop to fix a number and a two-pointer loop to find the remaining two numbers
* **Space Complexity:** O(1) – only constant space aside from the input array and result

```kotlin
fun threeSum(nums: IntArray): List<List<Int>> {
    val result = mutableListOf<List<Int>>()
  
    nums.sort()
  
    for (i in nums.indices) {
        if (i > 0 && nums[i] == nums[i - 1]) continue
        var left = i + 1
        var right = nums.size - 1
  
        while (left < right) {
            when {
                nums[i] + nums[left] + nums[right] == 0 -> {
                    result.add(listOf(nums[i], nums[left], nums[right]))
                    left++
                    right--
                    while (left < right && nums[left] == nums[left - 1]) left++
                    while (left < right && nums[right] == nums[right + 1]) right--
                }
              
                nums[i] + nums[left] + nums[right] < 0 -> left++
              
                else -> right--
            }
        }
    }
  
    return result
}
```

## Complexity Comparison:

| Approach | Time Complexity | Space Complexity |
|----------|----------------|------------------|
| Hashing | O(n²) | O(n) |
| Two Pointers | O(n²) | O(1) |

## Conclusion:

The Two Pointers approach is the most efficient solution for this problem with a time complexity of O(n²). The sorting step simplifies the process of finding valid triplets and avoiding duplicates. While the Hashing method is also efficient, it uses additional space for the hash set, making the two-pointer method more optimal in terms of space.
